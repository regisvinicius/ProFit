# Internacionalização (i18n) — backend

O backend está preparado para i18n: todas as mensagens voltadas ao cliente estão centralizadas em **`apps/backend/src/lib/errors.ts`** no objeto **`ERRORS`**.

---

## O que já existe

- **`ERRORS`** — chaves em inglês com mensagens (ex.: `EMAIL_ALREADY_REGISTERED`, `INVALID_EMAIL_OR_PASSWORD`).
- **`AppError(statusCode, message, code?)`** — serviços lançam `throw new AppError(409, ERRORS.EMAIL_ALREADY_REGISTERED)`.
- **`createErrorHandler()`** — envia `{ error: error.message }` na resposta.

---

## Como implementar i18n

1. **Definir locale**  
   Resolver idioma por requisição: header `Accept-Language`, query `?locale=pt`, ou body. Ex.: hook Fastify que define `request.locale` (fallback `en`).

2. **Função de tradução**  
   Criar `t(locale: string, key: keyof typeof ERRORS)` (ou mapeamento key → string) que devolve a string no idioma certo. Arquivos de tradução por idioma (ex.: `locales/pt.json`, `locales/en.json`) com as mesmas chaves de `ERRORS`.

3. **AppError com chave**  
   Opção A: continuar passando `ERRORS.XXX` (já é uma string) e no error handler traduzir por chave (ex.: manter um mapa `ERROR_KEY → message` por locale).  
   Opção B: passar uma chave em vez da mensagem, ex. `AppError(409, 'EMAIL_ALREADY_REGISTERED')` e no handler fazer `t(request.locale, error.message)`.

4. **Error handler**  
   No `createErrorHandler()`, antes de `reply.send({ error: error.message })`, obter o locale do request (decorator ou header) e usar `t(locale, error.message)` (ou a chave que você tiver em `AppError`) para enviar a mensagem traduzida.

5. **Outras mensagens**  
   Qualquer outra string voltada ao cliente (ex.: respostas de sucesso, labels em OpenAPI) seguir o mesmo padrão: chave ou constante → `t(locale, key)`.

---

## Resumo

- **Hoje:** uma única fonte de mensagens (`ERRORS`).
- **Com i18n:** mesma fonte de chaves; resposta ao cliente = `t(locale, key)` no handler ou nos pontos que montam o body.
